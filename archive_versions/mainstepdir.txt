/**************************************************
 * Sensorless Homing with TMC2209 on Arduino Uno
 * Adapted from HomeX sketch by Teemu MÃ¤ntykallio
 *
 * Homes on power up.
 * Send 'x' followed by int to begin stepping.
 * Send 'h' to re-home.
 *
 * Wiring:
 * - STEP: Pin 5
 * - DIR: Pin 4
 * - EN: Pin 6
 * - SW_RX: Pin 7 (connect to TMC2209 PDN_UART via 1k resistor to SW_TX)
 * - SW_TX: Pin 8 (connect to TMC2209 PDN_UART)
 * - DIAG: Pin 3 (stallGuard detection)
 * - 1k resistor between pins 7 and 8
 *
 * Motor direction controlled by UART: driver.shaft(true or false)
 **************************************************/

#include <Arduino.h>
#include <TMCStepper.h>
#include <SoftwareSerial.h>

// Pin Definitions
#define EN_PIN 6    // Enable
#define STEP_PIN 5  // Step
#define STALL_PIN 3 // DIAG pin from TMC2209
#define SW_RX 7     // SoftwareSerial RX
#define SW_TX 8     // SoftwareSerial TX

// TMC2209 Configuration
#define DRIVER_ADDRESS 0b00 // TMC2209 Driver address according to MS1 and MS2
#define R_SENSE 0.11f       // Match to your driver (SilentStepStick = 0.11)

// StallGuard Configuration
// Higher value of STALL_VALUE increases stall sensitivity
// DIAG pin pulsed HIGH when SG_RESULT falls below 2*STALL_VALUE
// Must be in StealthChop Mode for stallGuard to work
// Value of TCOOLTHRS must be greater than TSTEP & TPWMTHRS
#define STALL_VALUE 50 // [0..255]

// Timing
int stepTime = 160;  // Microseconds per step pulse
bool startup = true; // Set false after homing

// Create SoftwareSerial and driver objects
SoftwareSerial SoftSerial(SW_RX, SW_TX);
TMC2209Stepper driver(&SoftSerial, R_SENSE, DRIVER_ADDRESS);

// Global state
bool shaftVal = false;         // Motor direction
volatile bool stalled = false; // Flag set when motor stalls

//== Function Prototypes ========================================================

// void motor(int steps, int stepDelay);
// void homeX();

// //== Interrupt Service Routine ==================================================

// void stallInterrupt() {
//   // Flag set when motor stalls
//   stalled = true;
// }

// //== Setup =======================================================================

// void setup() {
//   // Initialize pins
//   pinMode(EN_PIN, OUTPUT);
//   pinMode(STEP_PIN, OUTPUT);
//   pinMode(STALL_PIN, INPUT);

//   // Initialize serial communication
//   Serial.begin(115200);           // Hardware serial for debugging
//   while (!Serial);                // Wait for serial port to connect
//   SoftSerial.begin(115200);       // Software serial for TMC2209 UART

//   Serial.println("TMC2209 Sensorless Homing");
//   Serial.println("Wiring: EN=6, STEP=5, SW_RX=7, SW_TX=8, DIAG=3");
//   Serial.println("Commands: 'h' to home, 'x' + number to step");
//   delay(500);

//   // Initialize TMC2209
//   driver.begin();                 // Init UART
//   driver.toff(4);                 // Enables driver in software (changed from 5)
//   driver.blank_time(24);
//   driver.rms_current(400);        // Set motor RMS current in mA
//   driver.microsteps(16);          // Set microsteps to 1/16th

//   // StealthChop and stallGuard configuration
//   driver.pwm_autoscale(true);     // Needed for stealthChop
//   driver.semin(5);                // Minimum StallGuard value for smart current control
//   driver.semax(2);                // Maximum StallGuard value for smart current control
//   driver.sedn(0b01);              // Current down step speed
//   driver.shaft(shaftVal);         // Set initial direction

//   // TCOOLTHRS needs to be set for stallGuard to work
//   driver.TCOOLTHRS(0xFFFFF);      // 20bit max
//   driver.SGTHRS(STALL_VALUE);     // StallGuard threshold

//   // Attach interrupt to DIAG pin
//   attachInterrupt(digitalPinToInterrupt(STALL_PIN), stallInterrupt, RISING);

//   // Enable driver in hardware
//   digitalWrite(EN_PIN, LOW);      // Active LOW

//   Serial.println("TMC2209 initialized");
//   delay(500);
// }

// //== Loop ========================================================================

// void loop() {
//   // Home on startup
//   if (startup) {
//     startup = false;
//     homeX();
//   }

//   // Handle stall detection
//   if (stalled) {
//     int backSteps = 1000;
//     Serial.println(">>> STALL DETECTED");
//     stalled = false;

//     // Reverse direction and back off
//     shaftVal = !shaftVal;
//     motor(backSteps, 160);
//   }

//   // Handle serial commands
//   if (Serial.available() > 0) {
//     char readVal = Serial.read();

//     if (readVal == 'x') {
//       // 'x' followed by integer: step that many steps
//       int steps = Serial.parseInt();
//       if (steps < 0) {
//         shaftVal = true;
//         steps *= -1;
//       } else {
//         shaftVal = false;
//       }
//       Serial.print("Stepping ");
//       Serial.print(steps);
//       Serial.print(" steps, direction: ");
//       Serial.println(shaftVal ? "reverse" : "forward");
//       motor(steps, 160);
//     }
//     else if (readVal == 'h') {
//       // 'h': re-home
//       Serial.println("Re-homing...");
//       homeX();
//     }
//   }
// }

// //== Homing Function =============================================================

// void homeX() {
//   int homeDelay = 160;
//   int backSteps = 5000;

//   // Fast homing
//   Serial.println(">>> Fast homing...");
//   shaftVal = true;
//   while (!stalled) {
//     motor(1000, homeDelay);
//   }
//   stalled = false;
//   delay(1000);

//   // Back off
//   Serial.println(">>> Backing off...");
//   shaftVal = false;
//   motor(backSteps, homeDelay);

//   // Slow homing for precision
//   Serial.println(">>> Slow homing...");
//   shaftVal = true;
//   while (!stalled) {
//     motor(1000, homeDelay * 2);
//   }
//   stalled = false;
//   delay(1000);

//   // Final back off
//   Serial.println(">>> Final back off...");
//   shaftVal = false;
//   motor(backSteps, homeDelay);

//   Serial.println(">>> Homing complete!");
// }

// //== Motor Control Function ======================================================

// void motor(int steps, int stepDelay) {
//   digitalWrite(EN_PIN, LOW);      // Ensure driver is enabled
//   driver.shaft(shaftVal);         // Set direction via UART

//   for (int i = 0; i < steps; i++) {
//     digitalWrite(STEP_PIN, HIGH);
//     delayMicroseconds(stepDelay);
//     digitalWrite(STEP_PIN, LOW);
//     delayMicroseconds(stepDelay);

//     // Exit early if stall detected
//     if (stalled) {
//       i = steps;
//     }
//   }

//   digitalWrite(EN_PIN, HIGH);     // Disable driver when done
// }
